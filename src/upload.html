<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Upload - Audio Transcription</title>
    <link rel="stylesheet" href="styles.css" />
  </head>
  <body>
    <div class="container">
      <h1>Audio Transcription</h1>
      <p class="subtitle">Upload a file or record audio directly.</p>

      <!-- Tab Switcher -->
      <div class="tab-switcher">
        <button class="tab-btn active" id="upload-tab" data-mode="upload">
          Upload File
        </button>
        <button class="tab-btn" id="record-tab" data-mode="record">
          Record Audio
        </button>
      </div>

      <div class="error-message" id="error-message"></div>

      <!-- Progress Bar -->
      <div class="progress-container" id="progress-container">
        <div class="progress-bar">
          <div class="progress-fill"></div>
        </div>
        <div class="progress-text">Transcribing your audio... This may take a moment.</div>
      </div>

      <!-- Upload Mode -->
      <div id="upload-mode" class="mode-container">
        <div class="drop-zone" id="drop-zone">
          <div class="drop-text">Drop audio file here or click to browse</div>
          <div class="drop-subtext">Supports MP3, WAV, M4A, WEBM, MP4 ‚Ä¢ Large files supported</div>
          <input
            type="file"
            id="file-input"
            accept=".mp3,.wav,.m4a,.webm,.mp4,.mpeg,.mpga"
            style="display: none"
          />
        </div>

        <div class="file-info" id="file-info">
          <div class="file-name" id="file-name"></div>
          <div class="file-size" id="file-size"></div>
        </div>
      </div>

      <!-- Record Mode -->
      <div id="record-mode" class="mode-container" style="display: none">
        <div class="record-container">
          <div class="record-visualizer" id="record-visualizer">
            <div class="record-status" id="record-status">Ready to record</div>
            <div class="record-timer" id="record-timer">00:00</div>
          </div>

          <div class="record-controls">
            <button class="record-btn" id="start-record-btn">
              <span class="record-dot"></span>
              Record
            </button>
            <button class="record-btn secondary" id="stop-record-btn" style="display: none">
              <span class="stop-icon"></span>
              Stop
            </button>
          </div>
        </div>

        <div class="file-info" id="recording-info" style="display: none">
          <div class="file-name" id="recording-name">Recording.webm</div>
          <div class="file-size" id="recording-size"></div>
        </div>
      </div>

      <!-- Model Selection -->
      <div class="model-selection" id="model-selection" style="display: none">
        <div class="model-option">
          <input type="radio" id="model-fast" name="model" value="gpt-4o-transcribe" checked />
          <label for="model-fast">
            <div class="model-label">
              <span class="model-title">‚ö° Fast Transcription</span>
              <span class="model-speed">~15 seconds per 10 minutes</span>
            </div>
            <div class="model-description">High-quality transcription without speaker identification</div>
          </label>
        </div>
        <div class="model-option">
          <input type="radio" id="model-diarize" name="model" value="gpt-4o-transcribe-diarize" />
          <label for="model-diarize">
            <div class="model-label">
              <span class="model-title">üé§ Speaker Identification</span>
              <span class="model-speed">Takes 10-20 minutes for large files</span>
            </div>
            <div class="model-description">Identifies who is speaking with diarization (slower processing)</div>
          </label>
        </div>
      </div>

      <!-- Speaker References Section -->
      <div class="speaker-section" id="speaker-section" style="display: none">
        <div class="speaker-header" id="speaker-header">
          <div class="speaker-header-content">
            <span class="speaker-title">Known Speakers</span>
            <span class="speaker-subtitle">Optional - Upload 2-10 second clips</span>
          </div>
          <span class="speaker-chevron" id="speaker-chevron">‚ñº</span>
        </div>
        <div class="speaker-body" id="speaker-body">
          <div class="speaker-list" id="speaker-list">
            <!-- Speaker reference items will be added here dynamically -->
          </div>
          <button class="btn-add-speaker" id="add-speaker-btn">+ Add Speaker</button>
          <div class="speaker-hint">Upload short audio clips (2-10 seconds) to identify specific speakers by name</div>
          <input type="file" id="speaker-input" accept=".mp3,.wav,.m4a,.webm,.mp4,.mpeg,.mpga" style="display: none" />
        </div>
      </div>

      <button class="btn" id="transcribe-btn" style="display: none">
        Transcribe
      </button>

      <!-- History Section -->
      <div class="history-section" id="history-section" style="display: none">
        <div class="history-header">
          <div class="history-title">Recent Transcriptions</div>
          <div class="history-count" id="history-count">0</div>
        </div>
        <div class="history-gallery" id="history-gallery">
          <!-- History cards will be inserted here -->
        </div>
        <div class="history-empty" id="history-empty">
          <div class="history-empty-icon">üìù</div>
          <div class="history-empty-text">No transcriptions yet</div>
        </div>
      </div>

      <button class="btn btn-secondary" id="settings-btn">Change API Key</button>

      <footer class="attribution">
        Created by <a href="https://patrickfreyer.com" target="_blank">Patrick C. Freyer</a>
        <br>
        <a href="mailto:freyer.patrick@bcg.com">freyer.patrick@bcg.com</a>
      </footer>
    </div>

    <script>
      // UI Elements
      const uploadTab = document.getElementById('upload-tab');
      const recordTab = document.getElementById('record-tab');
      const uploadMode = document.getElementById('upload-mode');
      const recordMode = document.getElementById('record-mode');
      const dropZone = document.getElementById('drop-zone');
      const fileInput = document.getElementById('file-input');
      const fileInfo = document.getElementById('file-info');
      const fileName = document.getElementById('file-name');
      const fileSize = document.getElementById('file-size');
      const recordingInfo = document.getElementById('recording-info');
      const recordingName = document.getElementById('recording-name');
      const recordingSize = document.getElementById('recording-size');
      const startRecordBtn = document.getElementById('start-record-btn');
      const stopRecordBtn = document.getElementById('stop-record-btn');
      const recordStatus = document.getElementById('record-status');
      const recordTimer = document.getElementById('record-timer');
      const transcribeBtn = document.getElementById('transcribe-btn');
      const settingsBtn = document.getElementById('settings-btn');
      const errorMessage = document.getElementById('error-message');
      const progressContainer = document.getElementById('progress-container');
      const modelSelection = document.getElementById('model-selection');
      const modelFast = document.getElementById('model-fast');
      const modelDiarize = document.getElementById('model-diarize');
      const speakerSection = document.getElementById('speaker-section');
      const speakerHeader = document.getElementById('speaker-header');
      const speakerBody = document.getElementById('speaker-body');
      const speakerChevron = document.getElementById('speaker-chevron');
      const speakerList = document.getElementById('speaker-list');
      const addSpeakerBtn = document.getElementById('add-speaker-btn');
      const speakerInput = document.getElementById('speaker-input');
      const historySection = document.getElementById('history-section');
      const historyGallery = document.getElementById('history-gallery');
      const historyCount = document.getElementById('history-count');
      const historyEmpty = document.getElementById('history-empty');

      let selectedFile = null;
      let isSpeakerExpanded = false;
      let mediaRecorder = null;
      let audioChunks = [];
      let recordingStartTime = null;
      let timerInterval = null;
      let currentMode = 'upload';
      let speakerReferences = []; // { name: string, file: File }
      let currentSpeakerIndex = null;

      // Tab Switching
      uploadTab.addEventListener('click', () => switchMode('upload'));
      recordTab.addEventListener('click', () => switchMode('record'));

      function switchMode(mode) {
        currentMode = mode;

        // Update tabs
        uploadTab.classList.toggle('active', mode === 'upload');
        recordTab.classList.toggle('active', mode === 'record');

        // Update containers
        uploadMode.style.display = mode === 'upload' ? 'block' : 'none';
        recordMode.style.display = mode === 'record' ? 'block' : 'none';

        // Reset state
        selectedFile = null;
        transcribeBtn.style.display = 'none';
        fileInfo.classList.remove('show');
        recordingInfo.style.display = 'none';
        errorMessage.classList.remove('show');
        speakerSection.style.display = 'none';
        speakerReferences = [];
        updateSpeakerList();
        modelSelection.style.display = 'none';
      }

      // ==================== MODEL SELECTION ====================

      // Update model display based on selection
      function updateModelDisplay() {
        const isDiarizeSelected = modelDiarize.checked;
        speakerSection.style.display = isDiarizeSelected ? 'block' : 'none';

        // Reset speaker references if switching to fast mode
        if (!isDiarizeSelected) {
          speakerReferences = [];
          updateSpeakerList();
        }
      }

      // Handle model change
      modelFast.addEventListener('change', updateModelDisplay);
      modelDiarize.addEventListener('change', updateModelDisplay);

      // ==================== SPEAKER SECTION ====================

      // Toggle speaker section
      speakerHeader.addEventListener('click', () => {
        isSpeakerExpanded = !isSpeakerExpanded;
        speakerBody.classList.toggle('expanded', isSpeakerExpanded);
        speakerChevron.classList.toggle('expanded', isSpeakerExpanded);
      });

      // Add speaker reference
      addSpeakerBtn.addEventListener('click', () => {
        if (speakerReferences.length >= 4) {
          errorMessage.textContent = 'Maximum 4 speaker references allowed';
          errorMessage.classList.add('show');
          return;
        }
        speakerInput.click();
      });

      // Handle speaker file selection
      speakerInput.addEventListener('change', async (e) => {
        if (e.target.files.length > 0) {
          const file = e.target.files[0];

          // Check file size (2-10 seconds ~ 0.2-2MB for typical audio)
          const fileSizeInMB = file.size / (1024 * 1024);
          if (fileSizeInMB > 5) {
            errorMessage.textContent = 'Speaker reference files should be short (2-10 seconds)';
            errorMessage.classList.add('show');
            speakerInput.value = '';
            return;
          }

          // Prompt for speaker name
          const speakerName = await promptSpeakerName();
          if (!speakerName) {
            speakerInput.value = '';
            return;
          }

          // Save the file temporarily and get the path
          const arrayBuffer = await file.arrayBuffer();
          const result = await window.electron.saveRecording(arrayBuffer);

          if (result.success) {
            speakerReferences.push({
              name: speakerName,
              path: result.filePath,
              originalName: file.name
            });
            updateSpeakerList();
            speakerInput.value = '';
            errorMessage.classList.remove('show');
          }
        }
      });

      function promptSpeakerName() {
        return new Promise((resolve) => {
          const name = prompt('Enter speaker name:');
          resolve(name ? name.trim() : null);
        });
      }

      function updateSpeakerList() {
        speakerList.innerHTML = '';

        speakerReferences.forEach((speaker, index) => {
          const item = document.createElement('div');
          item.className = 'speaker-item';
          item.innerHTML = `
            <div class="speaker-item-content">
              <div class="speaker-item-name">${speaker.name}</div>
              <div class="speaker-item-file">${speaker.originalName}</div>
            </div>
            <button class="speaker-item-remove" data-index="${index}">√ó</button>
          `;
          speakerList.appendChild(item);
        });

        // Add remove handlers
        document.querySelectorAll('.speaker-item-remove').forEach(btn => {
          btn.addEventListener('click', (e) => {
            const index = parseInt(e.target.getAttribute('data-index'));
            speakerReferences.splice(index, 1);
            updateSpeakerList();
          });
        });

        addSpeakerBtn.disabled = speakerReferences.length >= 4;
      }

      // ==================== UPLOAD MODE ====================

      // Click to browse
      dropZone.addEventListener('click', () => {
        fileInput.click();
      });

      // File input change
      fileInput.addEventListener('change', (e) => {
        if (e.target.files.length > 0) {
          handleFile(e.target.files[0]);
        }
      });

      // Drag and drop events
      dropZone.addEventListener('dragover', (e) => {
        e.preventDefault();
        dropZone.classList.add('drag-over');
      });

      dropZone.addEventListener('dragleave', () => {
        dropZone.classList.remove('drag-over');
      });

      dropZone.addEventListener('drop', (e) => {
        e.preventDefault();
        dropZone.classList.remove('drag-over');

        if (e.dataTransfer.files.length > 0) {
          handleFile(e.dataTransfer.files[0]);
        }
      });

      function handleFile(file) {
        errorMessage.classList.remove('show');

        // Check file type
        const fileExtension = '.' + file.name.split('.').pop().toLowerCase();
        const acceptedExtensions = [
          '.mp3',
          '.wav',
          '.m4a',
          '.webm',
          '.mp4',
          '.mpeg',
          '.mpga',
        ];

        if (!acceptedExtensions.includes(fileExtension)) {
          errorMessage.textContent =
            'Unsupported file type. Please use MP3, WAV, M4A, WEBM, or MP4.';
          errorMessage.classList.add('show');
          return;
        }

        // Note: No file size limit check - large files are now supported via chunking
        selectedFile = file;

        // Display file info
        fileName.textContent = file.name;
        fileSize.textContent = formatFileSize(file.size);
        fileInfo.classList.add('show');
        modelSelection.style.display = 'flex';
        updateModelDisplay();
        transcribeBtn.style.display = 'block';
      }

      // ==================== RECORD MODE ====================

      startRecordBtn.addEventListener('click', async () => {
        try {
          const stream = await navigator.mediaDevices.getUserMedia({ audio: true });

          mediaRecorder = new MediaRecorder(stream, { mimeType: 'audio/webm' });
          audioChunks = [];

          mediaRecorder.ondataavailable = (event) => {
            audioChunks.push(event.data);
          };

          mediaRecorder.onstop = async () => {
            const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });

            // Stop all tracks
            stream.getTracks().forEach(track => track.stop());

            // Clear timer
            clearInterval(timerInterval);

            try {
              // Convert blob to array buffer and save to temp file
              const arrayBuffer = await audioBlob.arrayBuffer();
              const result = await window.electron.saveRecording(arrayBuffer);

              if (result.success) {
                // Store the temp file path as a File-like object
                selectedFile = {
                  path: result.filePath,
                  name: 'recording.webm',
                  size: audioBlob.size,
                };

                // Display recording info
                recordingSize.textContent = formatFileSize(audioBlob.size);
                recordingInfo.style.display = 'block';
                speakerSection.style.display = 'block';
                transcribeBtn.style.display = 'block';

                // Reset UI
                recordStatus.textContent = 'Recording complete';
                startRecordBtn.style.display = 'block';
                stopRecordBtn.style.display = 'none';
              } else {
                throw new Error(result.error);
              }
            } catch (error) {
              errorMessage.textContent = 'Failed to save recording: ' + error.message;
              errorMessage.classList.add('show');
              recordStatus.textContent = 'Ready to record';
              startRecordBtn.style.display = 'block';
              stopRecordBtn.style.display = 'none';
            }
          };

          mediaRecorder.start();
          recordingStartTime = Date.now();

          // Update UI
          recordStatus.textContent = 'Recording...';
          startRecordBtn.style.display = 'none';
          stopRecordBtn.style.display = 'block';
          recordingInfo.style.display = 'none';
          transcribeBtn.style.display = 'none';

          // Start timer
          timerInterval = setInterval(updateTimer, 1000);

        } catch (error) {
          errorMessage.textContent = 'Microphone access denied. Please enable microphone permissions.';
          errorMessage.classList.add('show');
        }
      });

      stopRecordBtn.addEventListener('click', () => {
        if (mediaRecorder && mediaRecorder.state !== 'inactive') {
          mediaRecorder.stop();
        }
      });

      function updateTimer() {
        const elapsed = Math.floor((Date.now() - recordingStartTime) / 1000);
        const minutes = Math.floor(elapsed / 60).toString().padStart(2, '0');
        const seconds = (elapsed % 60).toString().padStart(2, '0');
        recordTimer.textContent = `${minutes}:${seconds}`;
      }

      // ==================== SHARED ====================

      function formatFileSize(bytes) {
        if (bytes < 1024) return bytes + ' B';
        if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(2) + ' KB';
        return (bytes / (1024 * 1024)).toFixed(2) + ' MB';
      }

      // ==================== TRANSCRIPTION ====================

      // Listen for progress updates
      const progressText = document.querySelector('.progress-text');
      window.electron.onTranscriptionProgress((data) => {
        if (data.status === 'converting') {
          progressText.textContent = data.message || 'Converting audio format...';
        } else if (data.status === 'splitting') {
          progressText.textContent = data.message || 'Splitting large audio file...';
        } else if (data.status === 'transcribing') {
          if (data.current && data.total) {
            progressText.textContent = `${data.message} (${data.current}/${data.total})`;
          } else {
            progressText.textContent = data.message || 'Transcribing...';
          }
        } else if (data.status === 'combining') {
          progressText.textContent = data.message || 'Combining transcripts...';
        }
      });

      // Transcribe button
      transcribeBtn.addEventListener('click', async () => {
        if (!selectedFile) return;

        errorMessage.classList.remove('show');
        progressContainer.classList.add('show');
        progressText.textContent = 'Transcribing your audio... This may take a moment.';
        transcribeBtn.disabled = true;
        transcribeBtn.textContent = 'Transcribing...';

        try {
          const apiKey = await window.electron.getApiKey();

          if (!apiKey) {
            throw new Error('API key not found. Please set up your API key first.');
          }

          // Get selected model
          const model = modelDiarize.checked ? 'gpt-4o-transcribe-diarize' : 'gpt-4o-transcribe';

          const result = await window.electron.transcribeAudio(
            selectedFile.path,
            apiKey,
            {
              model: model,
              speakers: speakerReferences.length > 0 ? speakerReferences : null
            }
          );

          if (result.success) {
            // Store transcript in localStorage
            localStorage.setItem('transcript', result.transcript);
            localStorage.setItem('fileName', selectedFile.name);
            localStorage.setItem('transcriptModel', model);
            if (result.chunked) {
              localStorage.setItem('transcriptInfo', `Processed in ${result.totalChunks} chunks`);
            }
            if (result.isDiarized) {
              localStorage.setItem('isDiarized', 'true');
            }

            // Navigate to results screen (which will show combined view and auto-generate summary)
            window.electron.navigate('results');
          } else {
            throw new Error(result.error);
          }
        } catch (error) {
          errorMessage.textContent = error.message || 'Transcription failed';
          errorMessage.classList.add('show');
          progressContainer.classList.remove('show');
          transcribeBtn.disabled = false;
          transcribeBtn.textContent = 'Transcribe';
        }
      });

      // ==================== HISTORY GALLERY ====================

      // Load and display history
      async function loadHistory() {
        try {
          const result = await window.electron.getTranscriptionHistory();

          if (result.success && result.items.length > 0) {
            historySection.style.display = 'block';
            historyEmpty.style.display = 'none';
            historyGallery.style.display = 'grid';
            historyCount.textContent = result.items.length;

            // Render history cards
            historyGallery.innerHTML = '';
            result.items.forEach(item => {
              const card = createHistoryCard(item);
              historyGallery.appendChild(card);
            });
          } else {
            historySection.style.display = 'block';
            historyEmpty.style.display = 'block';
            historyGallery.style.display = 'none';
            historyCount.textContent = '0';
          }
        } catch (error) {
          console.error('Failed to load history:', error);
        }
      }

      // Create history card
      function createHistoryCard(item) {
        const card = document.createElement('div');
        card.className = 'history-card';

        const date = new Date(item.timestamp);
        const formattedDate = date.toLocaleDateString('en-US', {
          month: 'short',
          day: 'numeric',
          year: 'numeric',
          hour: '2-digit',
          minute: '2-digit'
        });

        const modelLabel = item.model === 'gpt-4o-transcribe-diarize' ? 'Speaker ID' : 'Standard';

        card.innerHTML = `
          <div class="history-card-header">
            <div class="history-card-info">
              <div class="history-card-filename">${item.fileName}</div>
              <div class="history-card-date">${formattedDate}</div>
            </div>
            <button class="history-card-delete" onclick="event.stopPropagation();" data-id="${item.id}">√ó</button>
          </div>
          <div class="history-card-preview">${item.transcriptPreview}...</div>
          <div class="history-card-model">${modelLabel}</div>
        `;

        // Add click handler to load transcription
        card.addEventListener('click', () => {
          localStorage.setItem('loadTranscriptionId', item.id);
          window.electron.navigate('results');
        });

        // Add delete handler
        const deleteBtn = card.querySelector('.history-card-delete');
        deleteBtn.addEventListener('click', async (e) => {
          e.stopPropagation();
          if (confirm(`Delete transcription "${item.fileName}"?`)) {
            try {
              await window.electron.deleteTranscription(item.id);
              await loadHistory(); // Reload history
            } catch (error) {
              console.error('Failed to delete:', error);
            }
          }
        });

        return card;
      }

      // Load history on page load
      loadHistory();

      // Settings button
      settingsBtn.addEventListener('click', () => {
        window.electron.navigate('setup');
      });
    </script>
  </body>
</html>
